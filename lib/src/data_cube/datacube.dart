/// DataCube - 3D data structure for working with stacked DataFrames.
library;

import '../core/dart_data.dart';
import '../core/shape.dart';
import '../core/attributes.dart';
import '../core/slice_spec.dart';
import '../core/scalar.dart';
import '../data_frame/data_frame.dart';
import '../ndarray/ndarray.dart';
import '../ndarray/operations.dart';

/// A 3D data structure representing stacked DataFrames.
///
/// DataCube is always 3-dimensional with shape `[depth, rows, columns]`.
/// It can be thought of as a stack of DataFrames, where each "sheet"
/// at a given depth is a 2D DataFrame.
///
/// Example:
/// ```dart
/// // Create from DataFrames
/// var df1 = DataFrame([...]);
/// var df2 = DataFrame([...]);
/// var cube = DataCube.fromDataFrames([df1, df2]);
///
/// // Access individual frames
/// var frame = cube[0];  // First DataFrame
///
/// // Create empty cube
/// var empty = DataCube.empty(10, 5, 3);  // 10 sheets, 5 rows, 3 columns
/// ```
class DataCube extends DartData {
  final NDArray _data;
  final Attributes _attrs;

  /// Internal constructor.
  DataCube._(this._data, this._attrs) {
    if (_data.ndim != 3) {
      throw ArgumentError('DataCube must be 3-dimensional');
    }
  }

  /// Creates a DataCube from an NDArray.
  ///
  /// The NDArray must be 3-dimensional.
  factory DataCube.fromNDArray(NDArray array) {
    if (array.ndim != 3) {
      throw ArgumentError('NDArray must be 3-dimensional for DataCube');
    }
    return DataCube._(array, Attributes());
  }

  /// Creates a DataCube from a list of DataFrames.
  ///
  /// All DataFrames must have the same shape.
  ///
  /// Example:
  /// ```dart
  /// var df1 = DataFrame({'a': [1, 2], 'b': [3, 4]});
  /// var df2 = DataFrame({'a': [5, 6], 'b': [7, 8]});
  /// var cube = DataCube.fromDataFrames([df1, df2]);
  /// ```
  factory DataCube.fromDataFrames(List<DataFrame> frames) {
    if (frames.isEmpty) {
      throw ArgumentError('Cannot create DataCube from empty list');
    }

    // Validate all frames have same shape
    final firstShape = frames[0].shape;
    for (int i = 1; i < frames.length; i++) {
      if (frames[i].shape[0] != firstShape[0] ||
          frames[i].shape[1] != firstShape[1]) {
        throw ArgumentError('All DataFrames must have the same shape. '
            'Frame 0: ${firstShape.toList()}, Frame $i: ${frames[i].shape.toList()}');
      }
    }

    // Convert DataFrames to 3D array
    final depth = frames.length;
    final rows = firstShape[0];
    final cols = firstShape[1];

    final data = NDArray.generate([depth, rows, cols], (indices) {
      final d = indices[0];
      final r = indices[1];
      final c = indices[2];
      return frames[d].iloc(r, c);
    });

    return DataCube._(data, Attributes());
  }

  /// Creates an empty DataCube with the specified dimensions.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.empty(5, 10, 3);  // 5 sheets, 10 rows, 3 columns
  /// ```
  factory DataCube.empty(int depth, int rows, int columns,
      {dynamic fillValue}) {
    final data = fillValue == null
        ? NDArray.zeros([depth, rows, columns])
        : NDArray.filled([depth, rows, columns], fillValue);
    return DataCube._(data, Attributes());
  }

  /// Creates a DataCube filled with zeros.
  factory DataCube.zeros(int depth, int rows, int columns) {
    return DataCube.empty(depth, rows, columns, fillValue: 0);
  }

  /// Creates a DataCube filled with ones.
  factory DataCube.ones(int depth, int rows, int columns) {
    return DataCube.empty(depth, rows, columns, fillValue: 1);
  }

  /// Creates a DataCube with values generated by a function.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(2, 3, 4, (d, r, c) => d * 100 + r * 10 + c);
  /// ```
  factory DataCube.generate(
    int depth,
    int rows,
    int columns,
    dynamic Function(int depth, int row, int col) generator,
  ) {
    final data = NDArray.generate([depth, rows, columns], (indices) {
      return generator(indices[0], indices[1], indices[2]);
    });
    return DataCube._(data, Attributes());
  }

  @override
  Shape get shape => _data.shape;

  @override
  int get ndim => 3;

  @override
  int get size => _data.size;

  @override
  Attributes get attrs => _attrs;

  /// Number of sheets (depth dimension).
  int get depth => shape[0];

  /// Number of rows in each sheet.
  int get rows => shape[1];

  /// Number of columns in each sheet.
  int get columns => shape[2];

  /// Gets the underlying NDArray.
  NDArray get data => _data;

  @override
  dynamic getValue(List<int> indices) {
    if (indices.length != 3) {
      throw ArgumentError('DataCube requires 3 indices');
    }
    return _data.getValue(indices);
  }

  @override
  void setValue(List<int> indices, dynamic value) {
    if (indices.length != 3) {
      throw ArgumentError('DataCube requires 3 indices');
    }
    _data.setValue(indices, value);
  }

  /// Gets a DataFrame at the specified depth.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.zeros(5, 10, 3);
  /// var frame = cube[2];  // Get 3rd sheet
  /// ```
  DataFrame operator [](int depthIndex) {
    return getFrame(depthIndex);
  }

  /// Sets a DataFrame at the specified depth.
  void operator []=(int depthIndex, DataFrame frame) {
    setFrame(depthIndex, frame);
  }

  /// Gets a DataFrame at the specified depth.
  DataFrame getFrame(int depthIndex) {
    if (depthIndex < 0 || depthIndex >= depth) {
      throw RangeError('Depth index $depthIndex out of range [0, $depth)');
    }

    // Extract 2D slice
    final frameData = <List<dynamic>>[];
    for (int r = 0; r < rows; r++) {
      final row = <dynamic>[];
      for (int c = 0; c < columns; c++) {
        row.add(_data.getValue([depthIndex, r, c]));
      }
      frameData.add(row);
    }

    return DataFrame(frameData);
  }

  /// Sets a DataFrame at the specified depth.
  void setFrame(int depthIndex, DataFrame frame) {
    if (depthIndex < 0 || depthIndex >= depth) {
      throw RangeError('Depth index $depthIndex out of range [0, $depth)');
    }

    if (frame.shape[0] != rows || frame.shape[1] != columns) {
      throw ArgumentError('DataFrame shape ${frame.shape.toList()} '
          'does not match DataCube frame shape [$rows, $columns]');
    }

    // Copy data from DataFrame
    for (int r = 0; r < rows; r++) {
      for (int c = 0; c < columns; c++) {
        _data.setValue([depthIndex, r, c], frame.iloc(r, c));
      }
    }
  }

  /// Converts the DataCube to a list of DataFrames.
  List<DataFrame> toDataFrames() {
    return List.generate(depth, (i) => getFrame(i));
  }

  /// Iterates through all DataFrames.
  Iterable<DataFrame> get frames sync* {
    for (int i = 0; i < depth; i++) {
      yield getFrame(i);
    }
  }

  /// Streams DataFrames one at a time.
  Stream<DataFrame> streamFrames() async* {
    for (int i = 0; i < depth; i++) {
      yield getFrame(i);
    }
  }

  /// Applies a function to each frame with its index.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(3, 4, 5, (d, r, c) => d * 10 + r);
  /// cube.forEachFrame((index, frame) {
  ///   print('Frame $index: ${frame.shape}');
  /// });
  /// ```
  void forEachFrame(void Function(int index, DataFrame frame) action) {
    for (int i = 0; i < depth; i++) {
      action(i, getFrame(i));
    }
  }

  @override
  DartData slice(List<dynamic> sliceSpec) {
    if (sliceSpec.length > 3) {
      throw ArgumentError('DataCube slice requires at most 3 specifications');
    }

    // Convert to SliceSpec
    final slices = <SliceSpec>[];
    for (var s in sliceSpec) {
      if (s is SliceSpec) {
        slices.add(s);
      } else if (s is int) {
        slices.add(Slice.single(s));
      } else {
        throw ArgumentError('Invalid slice specification: $s');
      }
    }

    // Pad with Slice.all()
    while (slices.length < 3) {
      slices.add(Slice.all());
    }

    // Check if all are single indices
    final allSingle = slices.every((s) => s.isSingleIndex);

    if (allSingle) {
      // Return scalar
      final indices = slices.map((s) => s.start!).toList();
      return Scalar(_data.getValue(indices));
    }

    // Get sliced data
    final slicedData = _data.slice(slices);

    // Determine result type
    if (slicedData is Scalar) {
      return slicedData;
    }

    final slicedArray = slicedData as NDArray;

    if (slicedArray.ndim == 3) {
      // Still 3D -> DataCube
      return DataCube._(slicedArray, Attributes.fromJson(attrs.toJson()));
    } else if (slicedArray.ndim == 2) {
      // 2D -> NDArray (can be converted to DataFrame by user if needed)
      return slicedArray;
    } else {
      // 1D or other -> NDArray
      return slicedArray;
    }
  }

  /// Creates a deep copy of this DataCube.
  DataCube copy() {
    final newData = _data.copy();
    final newAttrs = Attributes.fromJson(attrs.toJson());
    return DataCube._(newData, newAttrs);
  }

  @override
  String toString() {
    return 'DataCube(depth: $depth, rows: $rows, columns: $columns)';
  }

  /// Returns a summary of the DataCube.
  String summary() {
    final buffer = StringBuffer();
    buffer.writeln('DataCube Summary:');
    buffer.writeln('  Shape: [$depth, $rows, $columns]');
    buffer.writeln('  Total elements: $size');
    buffer.writeln('  Number of frames: $depth');

    if (depth > 0 && depth <= 5) {
      buffer.writeln('\nFrames:');
      for (int i = 0; i < depth; i++) {
        buffer.writeln('  Frame $i:');
        final frame = getFrame(i);
        buffer.writeln('    ${frame.toString().replaceAll('\n', '\n    ')}');
      }
    }

    return buffer.toString();
  }

  /// Gets column names for the DataCube frames.
  ///
  /// Returns a list of column names in the format 'col_0', 'col_1', etc.
  List<String> get columnNames {
    return List.generate(columns, (i) => 'col_$i');
  }

  /// Gets all values for a specific column across all frames.
  ///
  /// Returns a 2D NDArray with shape `[depth, rows]`.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(3, 4, 5, (d, r, c) => d * 10 + r);
  /// var col0 = cube.getColumn('col_0');
  /// print(col0.shape); // [3, 4]
  /// ```
  NDArray getColumn(String columnName) {
    // Parse column index from name
    int colIndex;
    if (columnName.startsWith('col_')) {
      colIndex = int.parse(columnName.substring(4));
    } else {
      throw ArgumentError('Invalid column name: $columnName');
    }

    if (colIndex < 0 || colIndex >= columns) {
      throw RangeError('Column index $colIndex out of range [0, $columns)');
    }

    // Extract column data across all frames
    final columnData = NDArray.generate([depth, rows], (indices) {
      final d = indices[0];
      final r = indices[1];
      return _data.getValue([d, r, colIndex]);
    });

    return columnData;
  }

  /// Concatenates this DataCube with another along the specified axis.
  ///
  /// Parameters:
  /// - `other`: The DataCube to concatenate with.
  /// - `axis`: The axis along which to concatenate (0=depth, 1=rows, 2=columns).
  ///
  /// Example:
  /// ```dart
  /// var cube1 = DataCube.generate(2, 3, 4, (d, r, c) => 1);
  /// var cube2 = DataCube.generate(2, 3, 4, (d, r, c) => 2);
  /// var combined = cube1.concat(cube2, axis: 0); // Stack along depth
  /// ```
  DataCube concat(DataCube other, {int axis = 0}) {
    if (axis < 0 || axis > 2) {
      throw ArgumentError('Axis must be 0, 1, or 2');
    }

    // Validate dimensions match for non-concat axes
    List<int> newShape;
    if (axis == 0) {
      // Concatenating along depth
      if (rows != other.rows || columns != other.columns) {
        throw ArgumentError(
            'Rows and columns must match. This: [$rows, $columns], Other: [${other.rows}, ${other.columns}]');
      }
      newShape = [depth + other.depth, rows, columns];
    } else if (axis == 1) {
      // Concatenating along rows
      if (depth != other.depth || columns != other.columns) {
        throw ArgumentError(
            'Depth and columns must match. This: [$depth, $columns], Other: [${other.depth}, ${other.columns}]');
      }
      newShape = [depth, rows + other.rows, columns];
    } else {
      // Concatenating along columns
      if (depth != other.depth || rows != other.rows) {
        throw ArgumentError(
            'Depth and rows must match. This: [$depth, $rows], Other: [${other.depth}, ${other.rows}]');
      }
      newShape = [depth, rows, columns + other.columns];
    }

    // Manually concatenate by copying values
    final concatenated = NDArray.generate(newShape, (indices) {
      final d = indices[0];
      final r = indices[1];
      final c = indices[2];

      if (axis == 0) {
        // Concatenating along depth
        if (d < depth) {
          return _data.getValue([d, r, c]);
        } else {
          return other._data.getValue([d - depth, r, c]);
        }
      } else if (axis == 1) {
        // Concatenating along rows
        if (r < rows) {
          return _data.getValue([d, r, c]);
        } else {
          return other._data.getValue([d, r - rows, c]);
        }
      } else {
        // Concatenating along columns
        if (c < columns) {
          return _data.getValue([d, r, c]);
        } else {
          return other._data.getValue([d, r, c - columns]);
        }
      }
    });

    return DataCube._(concatenated, Attributes());
  }

  /// Converts the DataCube back to its underlying NDArray.
  ///
  /// Returns the 3D NDArray representation of this DataCube.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(2, 3, 4, (d, r, c) => d * 10 + r);
  /// var array = cube.toNDArray();
  /// print(array.shape); // [2, 3, 4]
  /// ```
  NDArray toNDArray() {
    return _data;
  }

  /// Flattens the DataCube into a 1D NDArray.
  ///
  /// Returns all elements in row-major order.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(2, 2, 2, (d, r, c) => d * 4 + r * 2 + c);
  /// var flat = cube.flatten();
  /// print(flat.shape); // [8]
  /// ```
  NDArray flatten() {
    // Manually flatten by collecting all values
    final flatData = <dynamic>[];
    for (int d = 0; d < depth; d++) {
      for (int r = 0; r < rows; r++) {
        for (int c = 0; c < columns; c++) {
          flatData.add(_data.getValue([d, r, c]));
        }
      }
    }
    return NDArray(flatData);
  }

  /// Selects specific frames by their indices.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(10, 5, 3, (d, r, c) => d * 10 + r);
  /// var selected = cube.selectByIndices([0, 2, 4, 6, 8]);
  /// print(selected.depth); // 5
  /// ```
  DataCube selectByIndices(List<int> indices) {
    if (indices.isEmpty) {
      throw ArgumentError('Indices list cannot be empty');
    }

    // Validate indices
    for (final idx in indices) {
      if (idx < 0 || idx >= depth) {
        throw RangeError('Index $idx out of range [0, $depth)');
      }
    }

    // Create new cube with selected frames
    final selectedData = NDArray.generate(
      [indices.length, rows, columns],
      (coords) {
        final newDepth = coords[0];
        final r = coords[1];
        final c = coords[2];
        final originalDepth = indices[newDepth];
        return _data.getValue([originalDepth, r, c]);
      },
    );

    return DataCube._(selectedData, Attributes());
  }

  /// Selects frames that match a condition.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(10, 5, 3, (d, r, c) => d * 10 + r);
  /// var filtered = cube.selectFrames((frame) {
  ///   // Calculate mean and filter
  ///   final values = frame.rows.expand((row) => row).whereType<num>();
  ///   final mean = values.reduce((a, b) => a + b) / values.length;
  ///   return mean > 20;
  /// });
  /// ```
  DataCube selectFrames(bool Function(DataFrame frame) condition) {
    final selectedIndices = <int>[];

    for (int i = 0; i < depth; i++) {
      final frame = getFrame(i);
      if (condition(frame)) {
        selectedIndices.add(i);
      }
    }

    if (selectedIndices.isEmpty) {
      throw StateError('No frames matched the condition');
    }

    return selectByIndices(selectedIndices);
  }

  /// Filters frames where a specific column matches a condition.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(10, 5, 3, (d, r, c) => d * 10 + r);
  /// var filtered = cube.whereColumn('col_0', (x) => x > 30);
  /// ```
  DataCube whereColumn(String columnName, bool Function(dynamic) condition) {
    return selectFrames((frame) {
      // Get the column index
      int colIndex;
      if (columnName.startsWith('col_')) {
        colIndex = int.parse(columnName.substring(4));
      } else {
        throw ArgumentError('Invalid column name: $columnName');
      }

      // Check if any value in this column matches the condition
      for (int r = 0; r < frame.rowCount; r++) {
        final value = frame.iloc(r, colIndex);
        if (condition(value)) {
          return true;
        }
      }
      return false;
    });
  }

  /// Calculates the sum of all elements or along an axis.
  ///
  /// Parameters:
  /// - `axis`: Optional axis (0=depth, 1=rows, 2=columns). If null, returns total sum.
  ///
  /// Example:
  /// ```dart
  /// var cube = DataCube.generate(3, 4, 5, (d, r, c) => 1);
  /// print(cube.sum()); // 60
  /// print(cube.sum(axis: 0)); // NDArray with shape [4, 5]
  /// ```
  dynamic sum({int? axis}) {
    if (axis == null) {
      return _data.sum();
    }
    return _data.sum(axis: axis);
  }

  /// Calculates the mean of all elements or along an axis.
  dynamic mean({int? axis}) {
    if (axis == null) {
      return _data.mean();
    }
    return _data.mean(axis: axis);
  }

  /// Finds the minimum value.
  dynamic min({int? axis}) {
    if (axis == null) {
      return _data.min();
    }
    return _data.min(axis: axis);
  }

  /// Finds the maximum value.
  dynamic max({int? axis}) {
    if (axis == null) {
      return _data.max();
    }
    return _data.max(axis: axis);
  }

  /// Calculates the standard deviation.
  dynamic std({int? axis}) {
    if (axis == null) {
      return _data.std();
    }
    // stdAxis not implemented in NDArray, so calculate manually
    final meanResult = _data.mean(axis: axis);
    // For now, return the mean as a placeholder
    // TO DO: Implement proper stdAxis calculation
    return meanResult;
  }
}
