/// N-dimensional array implementation.
library;

import '../core/dart_data.dart';
import '../core/shape.dart';
import '../core/attributes.dart';
import '../core/slice_spec.dart';
import '../core/scalar.dart';
import '../storage/storage_backend.dart';
import '../storage/inmemory_backend.dart';
import '../core/ndarray_config.dart';

/// N-dimensional array with flexible storage backends.
class NDArray extends DartData {
  final StorageBackend _backend;
  final Attributes _attrs;

  /// Creates an NDArray from nested lists.
  factory NDArray(List<dynamic> data) {
    final shape = _inferShape(data);
    final flatData = _flatten(data);
    final backend = InMemoryBackend(flatData, shape);
    return NDArray._internal(backend, Attributes());
  }

  /// Creates an NDArray with explicit shape and data.
  factory NDArray.fromFlat(List<dynamic> data, List<int> shape) {
    final expectedSize = shape.reduce((a, b) => a * b);
    if (data.length != expectedSize) {
      throw ArgumentError(
          'Data length ${data.length} does not match shape $shape (expected $expectedSize)');
    }
    final backend = InMemoryBackend(data, Shape(shape));
    return NDArray._internal(backend, Attributes());
  }

  /// Creates an NDArray filled with zeros.
  factory NDArray.zeros(List<int> shape) {
    return NDArray._internal(InMemoryBackend.zeros(Shape(shape)), Attributes());
  }

  /// Creates an NDArray filled with ones.
  factory NDArray.ones(List<int> shape) {
    return NDArray._internal(InMemoryBackend.ones(Shape(shape)), Attributes());
  }

  /// Creates an NDArray filled with a specific value.
  factory NDArray.filled(List<int> shape, dynamic fillValue) {
    return NDArray._internal(
        InMemoryBackend.filled(Shape(shape), fillValue), Attributes());
  }

  /// Creates an NDArray with values generated by a function.
  factory NDArray.generate(
      List<int> shape, dynamic Function(List<int>) generator) {
    return NDArray._internal(
        InMemoryBackend.generate(Shape(shape), generator), Attributes());
  }

  /// Creates an NDArray with a custom storage backend.
  factory NDArray.withBackend(List<int> shape, StorageBackend backend) {
    return NDArray._internal(backend, Attributes());
  }

  /// Internal constructor.
  NDArray._internal(this._backend, this._attrs);

  @override
  Shape get shape => _backend.shape;

  @override
  int get ndim => shape.ndim;

  @override
  int get size => shape.size;

  @override
  Attributes get attrs => _attrs;

  /// Gets the storage backend.
  StorageBackend get backend => _backend;

  /// Gets a value at the specified indices.
  @override
  dynamic getValue(List<int> indices) {
    return _backend.getValue(indices);
  }

  /// Sets a value at the specified indices.
  @override
  void setValue(List<int> indices, dynamic value) {
    _backend.setValue(indices, value);
  }

  /// Gets a slice of the array.
  @override
  DartData slice(List<dynamic> sliceSpec) {
    // Convert dynamic slices to SliceSpec
    final slices = <SliceSpec>[];
    for (var s in sliceSpec) {
      if (s is SliceSpec) {
        slices.add(s);
      } else if (s is int) {
        slices.add(Slice.single(s));
      } else {
        throw ArgumentError('Invalid slice specification: $s');
      }
    }

    // Pad with Slice.all() for missing dimensions
    while (slices.length < shape.ndim) {
      slices.add(Slice.all());
    }

    // Check if all slices are single indices (result should be scalar)
    final allSingle = slices.every((s) => s.isSingleIndex);

    if (allSingle) {
      // All single indices -> return Scalar
      final indices = slices.map((s) => s.start!).toList();
      return Scalar(getValue(indices));
    }

    // Get sliced backend
    final slicedBackend = _backend.getSlice(slices);

    // N-D -> NDArray
    final result = NDArray._internal(slicedBackend, Attributes());
    // Copy attributes
    for (var key in attrs.keys) {
      result.attrs[key] = attrs[key];
    }
    return result;
  }

  /// Reshapes the array to a new shape.
  NDArray reshape(List<int> newShape) {
    final newShapeObj = Shape(newShape);
    if (newShapeObj.size != size) {
      throw ArgumentError(
          'Cannot reshape array of size $size into shape $newShape (size ${newShapeObj.size})');
    }

    // Get flat data and create new backend
    final flatData = _backend.getFlatData(copy: false);
    final newBackend = InMemoryBackend(flatData, newShapeObj);

    final result = NDArray._internal(newBackend, Attributes());
    // Copy attributes
    for (var key in attrs.keys) {
      result.attrs[key] = attrs[key];
    }
    return result;
  }

  /// Maps a function over all elements.
  NDArray map(dynamic Function(dynamic) fn) {
    return NDArray.generate(shape.toList(), (indices) => fn(getValue(indices)));
  }

  /// Filters elements based on a predicate.
  NDArray where(bool Function(dynamic) predicate) {
    final results = <dynamic>[];

    void iterate(List<int> indices, int dim) {
      if (dim == ndim) {
        final value = getValue(indices);
        if (predicate(value)) {
          results.add(value);
        }
        return;
      }

      for (int i = 0; i < shape[dim]; i++) {
        iterate([...indices, i], dim + 1);
      }
    }

    iterate([], 0);
    return NDArray.fromFlat(results, [results.length]);
  }

  /// Creates a deep copy of this array.
  NDArray copy() {
    final newBackend = _backend.clone();
    final newAttrs = Attributes.fromJson(attrs.toJson());
    return NDArray._internal(newBackend, newAttrs);
  }

  /// Converts the array to nested lists.
  List<dynamic> toNestedList() {
    if (ndim == 0) {
      return getValue([]);
    }

    if (ndim == 1) {
      return List.generate(shape[0], (i) => getValue([i]));
    }

    // Recursive construction for higher dimensions
    List<dynamic> buildNested(List<int> indices, int dim) {
      if (dim == ndim - 1) {
        return List.generate(shape[dim], (i) => getValue([...indices, i]));
      }

      return List.generate(
          shape[dim], (i) => buildNested([...indices, i], dim + 1));
    }

    return buildNested([], 0);
  }

  /// Gets the flat data as a list.
  List<dynamic> toFlatList({bool copy = true}) {
    return _backend.getFlatData(copy: copy);
  }

  @override
  String toString() {
    if (size == 0) {
      return 'NDArray(shape: $shape, empty)';
    }

    if (size <= 10) {
      return 'NDArray(shape: $shape, data: ${toNestedList()})';
    }

    return 'NDArray(shape: $shape, size: $size)';
  }

  // Helper methods

  /// Infers shape from nested lists.
  static Shape _inferShape(List<dynamic> data) {
    final dims = <int>[];
    dynamic current = data;

    while (current is List) {
      if (current.isEmpty) break;
      dims.add(current.length);
      current = current[0];
    }

    return Shape(dims);
  }

  /// Flattens nested lists into a 1D list.
  static List<dynamic> _flatten(List<dynamic> data) {
    final result = <dynamic>[];

    void flattenRecursive(dynamic item) {
      if (item is List) {
        for (var element in item) {
          flattenRecursive(element);
        }
      } else {
        result.add(item);
      }
    }

    flattenRecursive(data);
    return result;
  }
}
