/// N-dimensional array implementation.
library;

import '../core/dart_data.dart';
import '../core/shape.dart';
import '../core/attributes.dart';
import '../core/slice_spec.dart';
import '../core/scalar.dart';
import '../storage/storage_backend.dart';
import '../core/ndarray_config.dart';
import '../data_cube/datacube.dart';

/// N-dimensional array with flexible storage backends.
class NDArray extends DartData {
  final StorageBackend _backend;
  final Attributes _attrs;

  /// Creates an NDArray from nested lists.
  factory NDArray(List<dynamic> data) {
    final shape = _inferShape(data);
    final flatData = _flatten(data);
    final backend = NDArrayConfig.selectBackend(shape, initialData: flatData);
    return NDArray._internal(backend, Attributes());
  }

  /// Creates an NDArray with explicit shape and data.
  factory NDArray.fromFlat(List<dynamic> data, List<int> shape) {
    final expectedSize = shape.reduce((a, b) => a * b);
    if (data.length != expectedSize) {
      throw ArgumentError(
          'Data length ${data.length} does not match shape $shape (expected $expectedSize)');
    }
    final shapeObj = Shape(shape);
    final backend = NDArrayConfig.selectBackend(shapeObj, initialData: data);
    return NDArray._internal(backend, Attributes());
  }

  /// Creates an NDArray filled with zeros.
  factory NDArray.zeros(List<int> shape) {
    final shapeObj = Shape(shape);
    // Generate data first, then select backend
    final data = List.filled(shapeObj.size, 0);
    final backend = NDArrayConfig.selectBackend(shapeObj, initialData: data);
    return NDArray._internal(backend, Attributes());
  }

  /// Creates an NDArray filled with ones.
  factory NDArray.ones(List<int> shape) {
    final shapeObj = Shape(shape);
    // Generate data first, then select backend
    final data = List.filled(shapeObj.size, 1);
    final backend = NDArrayConfig.selectBackend(shapeObj, initialData: data);
    return NDArray._internal(backend, Attributes());
  }

  /// Creates an NDArray filled with a specific value.
  factory NDArray.filled(List<int> shape, dynamic fillValue) {
    final shapeObj = Shape(shape);
    // Generate data first, then select backend
    final data = List.filled(shapeObj.size, fillValue);
    final backend = NDArrayConfig.selectBackend(shapeObj, initialData: data);
    return NDArray._internal(backend, Attributes());
  }

  /// Creates an NDArray with values generated by a function.
  factory NDArray.generate(
      List<int> shape, dynamic Function(List<int>) generator) {
    final shapeObj = Shape(shape);
    // Generate data first, then select backend
    final data = List.generate(shapeObj.size, (i) {
      final indices = shapeObj.fromFlatIndex(i);
      return generator(indices);
    });
    final backend = NDArrayConfig.selectBackend(shapeObj, initialData: data);
    return NDArray._internal(backend, Attributes());
  }

  /// Creates an NDArray with a custom storage backend.
  factory NDArray.withBackend(List<int> shape, StorageBackend backend) {
    return NDArray._internal(backend, Attributes());
  }

  /// Internal constructor.
  NDArray._internal(this._backend, this._attrs);

  @override
  Shape get shape => _backend.shape;

  @override
  int get ndim => shape.ndim;

  @override
  int get size => shape.size;

  @override
  Attributes get attrs => _attrs;

  /// Gets the storage backend.
  StorageBackend get backend => _backend;

  /// Gets a value at the specified indices.
  @override
  dynamic getValue(List<int> indices) {
    return _backend.getValue(indices);
  }

  /// Sets a value at the specified indices.
  @override
  void setValue(List<int> indices, dynamic value) {
    _backend.setValue(indices, value);
  }

  /// Gets a slice of the array.
  @override
  DartData slice(List<dynamic> sliceSpec) {
    // Normalize slices to SliceSpec
    final slices = _normalizeSlices(sliceSpec);

    // Pad with Slice.all() for missing dimensions
    while (slices.length < shape.ndim) {
      slices.add(Slice.all());
    }

    // Calculate result shape
    final resultShape = _calculateResultShape(slices);

    // Create result based on dimensionality
    return _createResult(slices, resultShape);
  }

  /// Convenient slicing syntax using square brackets.
  ///
  /// Supports various slicing formats:
  /// - Single index: `array[0]` - returns lower-dimensional result
  /// - SliceSpec: `array[Slice.range(0, 10)]` - returns range
  /// - Multiple dimensions: Use `slice()` method with list
  ///
  /// Example:
  /// ```dart
  /// var array = NDArray.generate([5, 4, 3], (i) => i[0] * 100 + i[1] * 10 + i[2]);
  /// var frame = array[0];  // Get first 2D slice (DataFrame or NDArray)
  /// var scalar = array.slice([0, 0, 0]);  // Get single element (Scalar)
  /// ```
  DartData operator [](dynamic indexOrSlice) {
    return slice([indexOrSlice]);
  }

  /// Normalizes various slice formats to SliceSpec.
  List<SliceSpec> _normalizeSlices(List<dynamic> sliceSpec) {
    final slices = <SliceSpec>[];
    for (var s in sliceSpec) {
      if (s is SliceSpec) {
        slices.add(s);
      } else if (s is int) {
        slices.add(Slice.single(s));
      } else if (s == null) {
        slices.add(Slice.all());
      } else {
        throw ArgumentError('Invalid slice specification: $s');
      }
    }
    return slices;
  }

  /// Calculates the resulting shape after slicing.
  Shape _calculateResultShape(List<SliceSpec> slices) {
    final resultDims = <int>[];

    for (int i = 0; i < slices.length; i++) {
      if (!slices[i].isSingleIndex) {
        final dimSize = shape[i];
        final (start, stop, step) = slices[i].resolve(dimSize);
        final length = ((stop - start) / step).ceil().clamp(0, dimSize);
        resultDims.add(length);
      }
    }

    return Shape(resultDims);
  }

  /// Creates the appropriate result type based on dimensionality.
  DartData _createResult(List<SliceSpec> slices, Shape resultShape) {
    // Check if all slices are single indices (result should be scalar)
    final allSingle = slices.every((s) => s.isSingleIndex);

    if (allSingle) {
      // All single indices -> return Scalar
      final indices = slices.map((s) => s.start!).toList();
      return Scalar(getValue(indices));
    }

    // Get sliced backend
    final slicedBackend = _backend.getSlice(slices);

    // Create result based on dimensionality
    switch (resultShape.ndim) {
      case 0:
        // Should not happen if allSingle check works, but handle it
        return Scalar(slicedBackend.getValue([]));

      case 1:
        // 1D -> Series
        return _createSeries(slicedBackend);

      case 2:
        // 2D -> DataFrame
        return _createDataFrame(slicedBackend);

      case 3:
        // 3D -> DataCube
        return _createDataCube(slicedBackend);

      default:
        // N-D -> NDArray
        final result = NDArray._internal(slicedBackend, Attributes());
        // Copy attributes
        for (var key in attrs.keys) {
          result.attrs[key] = attrs[key];
        }
        return result;
    }
  }

  /// Creates a Series from a 1D sliced backend.
  DartData _createSeries(StorageBackend backend) {
    // For now, return as NDArray since Series doesn't implement DartData yet
    // This will be updated when Series is enhanced in task 31
    final result = NDArray._internal(backend, Attributes());
    for (var key in attrs.keys) {
      result.attrs[key] = attrs[key];
    }
    return result;
  }

  /// Creates a DataFrame from a 2D sliced backend.
  DartData _createDataFrame(StorageBackend backend) {
    // For now, return as NDArray since DataFrame doesn't implement DartData yet
    // This will be updated when DataFrame is enhanced in task 32
    final result = NDArray._internal(backend, Attributes());
    for (var key in attrs.keys) {
      result.attrs[key] = attrs[key];
    }
    return result;
  }

  /// Creates a DataCube from a 3D sliced backend.
  DartData _createDataCube(StorageBackend backend) {
    // DataCube already implements DartData, so we can create it directly
    final ndarray = NDArray._internal(backend, Attributes());
    // Copy attributes to the NDArray
    for (var key in attrs.keys) {
      ndarray.attrs[key] = attrs[key];
    }
    // Import DataCube at the top if not already imported
    return DataCube.fromNDArray(ndarray);
  }

  /// Reshapes the array to a new shape.
  NDArray reshape(List<int> newShape) {
    final newShapeObj = Shape(newShape);
    if (newShapeObj.size != size) {
      throw ArgumentError(
          'Cannot reshape array of size $size into shape $newShape (size ${newShapeObj.size})');
    }

    // Get flat data and create new backend using config
    final flatData = _backend.getFlatData(copy: NDArrayConfig.copyOnWrite);
    final newBackend =
        NDArrayConfig.selectBackend(newShapeObj, initialData: flatData);

    final result = NDArray._internal(newBackend, Attributes());
    // Copy attributes
    for (var key in attrs.keys) {
      result.attrs[key] = attrs[key];
    }
    return result;
  }

  /// Maps a function over all elements.
  NDArray map(dynamic Function(dynamic) fn) {
    // Generate mapped data first, then select backend
    final data = List.generate(size, (i) {
      final indices = shape.fromFlatIndex(i);
      final value = getValue(indices);
      return fn(value);
    });
    final newBackend = NDArrayConfig.selectBackend(shape, initialData: data);
    final result = NDArray._internal(newBackend, Attributes());
    // Copy attributes
    for (var key in attrs.keys) {
      result.attrs[key] = attrs[key];
    }
    return result;
  }

  /// Filters elements based on a predicate.
  NDArray where(bool Function(dynamic) predicate) {
    final results = <dynamic>[];

    void iterate(List<int> indices, int dim) {
      if (dim == ndim) {
        final value = getValue(indices);
        if (predicate(value)) {
          results.add(value);
        }
        return;
      }

      for (int i = 0; i < shape[dim]; i++) {
        iterate([...indices, i], dim + 1);
      }
    }

    iterate([], 0);
    return NDArray.fromFlat(results, [results.length]);
  }

  /// Creates a deep copy of this array.
  NDArray copy() {
    final newBackend = _backend.clone();
    final newAttrs = Attributes.fromJson(attrs.toJson());
    return NDArray._internal(newBackend, newAttrs);
  }

  /// Converts the array to nested lists.
  List<dynamic> toNestedList() {
    if (ndim == 0) {
      return getValue([]);
    }

    if (ndim == 1) {
      return List.generate(shape[0], (i) => getValue([i]));
    }

    // Recursive construction for higher dimensions
    List<dynamic> buildNested(List<int> indices, int dim) {
      if (dim == ndim - 1) {
        return List.generate(shape[dim], (i) => getValue([...indices, i]));
      }

      return List.generate(
          shape[dim], (i) => buildNested([...indices, i], dim + 1));
    }

    return buildNested([], 0);
  }

  /// Gets the flat data as a list.
  List<dynamic> toFlatList({bool copy = true}) {
    return _backend.getFlatData(copy: copy);
  }

  @override
  String toString() {
    if (size == 0) {
      return 'NDArray(shape: $shape, empty)';
    }

    if (size <= 10) {
      return 'NDArray(shape: $shape, data: ${toNestedList()})';
    }

    return 'NDArray(shape: $shape, size: $size)';
  }

  // Helper methods

  /// Infers shape from nested lists.
  static Shape _inferShape(List<dynamic> data) {
    final dims = <int>[];
    dynamic current = data;

    while (current is List) {
      if (current.isEmpty) break;
      dims.add(current.length);
      current = current[0];
    }

    return Shape(dims);
  }

  /// Flattens nested lists into a 1D list.
  static List<dynamic> _flatten(List<dynamic> data) {
    final result = <dynamic>[];

    void flattenRecursive(dynamic item) {
      if (item is List) {
        for (var element in item) {
          flattenRecursive(element);
        }
      } else {
        result.add(item);
      }
    }

    flattenRecursive(data);
    return result;
  }
}
